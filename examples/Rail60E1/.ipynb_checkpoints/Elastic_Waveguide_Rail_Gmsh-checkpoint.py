# This file is a tutorial for waveguicsx (*), whose inputs are
# the matrices K0, K1, K2, M and the excitation vector F.
# In the tutorial, K0, K1, K2 and M are finite element matrices generated by FEnicSX (**).
#  (*) waveguicsx is a python library for solving complex waveguide problems
#      Copyright (C) 2023  Fabien Treyssede
#      waveguicsx is free software distributed under the GNU General Public License
#      (https://github.com/treyssede/waveguicsx)
# (**) FEniCSx is an open-source computing platform for solving partial differential equations
#      distributed under the GNU Lesser General Public License (https://fenicsproject.org/)

##################################
# 3D elastic waveguide example\
# The cross-section is a 2D rail profile (60E1, 60.21kg/m) with free boundary conditions on its 1D boundaries, material: elastic steel\
# The waveguide FE formulation (SAFE) leads to the following eigenvalue problem:\
# $(\textbf{K}_1-\omega^2\textbf{M}+\text{i}k(\textbf{K}_2+\textbf{K}_2^\text{T})+k^2\textbf{K}_3)\textbf{U}=\textbf{0}$\
# This eigenproblem is solved with the varying parameter as the frequency (eigenvalues are then wavenumbers).\
# The FE mesh is built from gmsh with a .geo file.

import dolfinx
import ufl
from mpi4py import MPI
from petsc4py import PETSc
from slepc4py import SLEPc
import numpy as np
import matplotlib.pyplot as plt
import pyvista

from waveguicsx.waveguide import Waveguide
#For proper use with a jupyter notebook, uncomment the following line:
#pyvista.set_jupyter_backend("none"); pyvista.start_xvfb() #try also: "static", "pythreejs", "ipyvtklink"...

##################################
# Input parameters
a = np.sqrt(76.70e-4)/2 #characteristic length (m) = halfwidth of a square of identical cross-section (rail cross-section : 76.70cm2)
le = a/8 #finite element characteristic length (m)
rho, cs, cl = 7850.0, 3207.7, 6001.0 #density (kg/m3), shear and longitudinal wave celerities (m/s)
kappas, kappal = 0*0.008, 0*0.003 #shear and longitudinal bulk wave attenuations (Np/wavelength)
omega, nev = 2*np.pi*np.linspace(100, 5000, 50), 20 #angular frequencies (rad/s) and number of eigenvalues (low-frequency regime)
#wavenumber, nev = 2*np.pi*np.linspace(1e3, 1e5, 100)/cs, 100 #angular frequencies (rad/s) and number of eigenvalues (high-frequency regime)
#reminder:
#E, nu, rho = 2.1e+11, 0.3, 7850
#cs = np.sqrt(E/rho/(2*(1+nu)))
#cl = np.sqrt(E/rho*(1-nu)/((1+nu)*(1-2*nu)))

##################################
# Re-scaling
L0 = a #characteristic length
T0 = a/cs #characteristic time
M0 = rho*a**3#characteristic mass
a, le = a/L0, le/L0
rho, cs, cl = rho/M0*L0**3, cs/L0*T0, cl/L0*T0
omega = omega*T0
#wavenumber = wavenumber*L0
cs, cl = cs/(1+1j*kappas/2/np.pi), cl/(1+1j*kappal/2/np.pi) #complex celerities

##################################
# Build mesh from Gmsh and import to dolfinx (six-node triangles with three dofs per node for the three components of displacement)

!gmsh rail60E1_60.21kg_m.geo -2 -order 2 -setnumber Mesh.MeshSizeFactor {le*L0*1000} -setnumber Mesh.ScalingFactor {1/(1000*L0)} #units in .geo are in mm
mesh, cell_tags, facet_tags = dolfinx.io.gmshio.read_from_msh("rail60E1_60.21kg_m.msh", MPI.COMM_WORLD, rank=0, gdim=2)

##################################
# Visualize FE mesh with pyvista
Vmesh = dolfinx.fem.FunctionSpace(mesh, ufl.FiniteElement("CG", "triangle", 1)) #order 1 is properly handled with pyvista
plotter = pyvista.Plotter()
grid = pyvista.UnstructuredGrid(*dolfinx.plot.create_vtk_mesh(Vmesh))
grid.cell_data["Marker"] = cell_tags.values
grid.set_active_scalars("Marker")
plotter.add_mesh(grid, show_edges=True, show_scalar_bar=False)
plotter.view_xy()
plotter.show()
# Finite element space
element = ufl.VectorElement("CG", "triangle", 2, 3) #Lagrange element, triangle, quadratic "P2", 3D vector
V = dolfinx.fem.FunctionSpace(mesh, element)

##################################
# Create Material properties (isotropic)
def isotropic_law(rho, cs, cl):
    E, nu = rho*cs**2*(3*cl**2-4*cs**2)/(cl**2-cs**2), 0.5*(cl**2-2*cs**2)/(cl**2-cs**2)
    C11 = C22 = C33 = E/(1+nu)/(1-2*nu)*(1-nu)
    C12 = C13 = C23 = E/(1+nu)/(1-2*nu)*nu
    C44 = C55 = C66 = E/(1+nu)/2
    return np.array([[C11,C12,C13,0,0,0], 
                     [C12,C22,C23,0,0,0], 
                     [C13,C23,C33,0,0,0], 
                     [0,0,0,C44,0,0], 
                     [0,0,0,0,C55,0], 
                     [0,0,0,0,0,C66]])
C = isotropic_law(rho, cs, cl)
C = dolfinx.fem.Constant(mesh, PETSc.ScalarType(C))

##################################
# Create free boundary conditions
bcs = []

##################################
# Define variational problem (SAFE method)
u = ufl.TrialFunction(V)
v = ufl.TestFunction(V)
Lxy = lambda u: ufl.as_vector([u[0].dx(0), u[1].dx(1), 0, u[0].dx(1)+u[1].dx(0), u[2].dx(0), u[2].dx(1)])
Lz  = lambda u: ufl.as_vector([0, 0, u[2], 0, u[0], u[1]])
k0 = ufl.inner(C*Lxy(u), Lxy(v)) * ufl.dx
k0_form = dolfinx.fem.form(k0)
k1 = ufl.inner(C*Lz(u), Lxy(v)) * ufl.dx
k1_form = dolfinx.fem.form(k1)
k2 = ufl.inner(C*Lz(u), Lz(v)) * ufl.dx
k2_form = dolfinx.fem.form(k2)
m = rho*ufl.inner(u, v) * ufl.dx
mass_form = dolfinx.fem.form(m)

##################################
# Build PETSc matrices
M = dolfinx.fem.petsc.assemble_matrix(mass_form, bcs=bcs, diagonal=0.0)
M.assemble()
K0 = dolfinx.fem.petsc.assemble_matrix(k0_form, bcs=bcs)
K0.assemble()
K1 = dolfinx.fem.petsc.assemble_matrix(k1_form, bcs=bcs, diagonal=0.0)
K1.assemble()
K2 = dolfinx.fem.petsc.assemble_matrix(k2_form, bcs=bcs, diagonal=0.0)
K2.assemble()

##################################
# Solve the eigenproblem with SLEPc (the parameter is omega, the eigenvalue is k)
wg = Waveguide(MPI.COMM_WORLD, M, K0, K1, K2)
wg.set_parameters(omega=omega)
#wg.set_parameters(wavenumber=wavenumber)
wg.evp.setTolerances(tol=1e-8, max_it=20)
wg.solve(nev=nev, target=0) #access to components with: wg.eigenvalues[ik][imode], wg.eigenvectors[ik][idof,imode]

##################################
# Plot dispersion curves in the low-frequency regime (for comparison, see e.g. Zhang et al., Mechanical Systems and Signal Processing, 150, 1-22 (2021))
wg.set_plot_scaler(length=L0, time=T0, mass=M0)
sc = wg.plot()
sc.axes.set_xlim([0, 25])
sc.axes.set_ylim([0, 5000])
sc = wg.plot_phase_velocity()
sc.axes.set_xlim([0, 5000])
sc.axes.set_ylim([0, 6000])
sc = wg.plot_group_velocity(direction=+1)
sc.axes.set_xlim([0, 5000])
sc.axes.set_ylim([0, 6000])
plt.show()

###############################################################################
# Plot phase velocity dispersion curves in the high-frequency regime (for comparison, see e.g. Ge et al., Structural Health Monitoring, 21, 1287-1308 (2022))
if False:
    wg.set_plot_scaler(length=L0, time=T0, mass=M0)
    wg.plot_scaler['frequency'] = wg.plot_scaler['frequency']/1000
    sc = wg.plot_phase_velocity()
    sc.axes.set_xlim([0, 1e2])
    sc.axes.set_ylim([0, 12000])
    sc.axes.set_xlabel('frequency (kHz)')
    sc.axes.set_ylabel('phase velocity (m/s)')
    #plt.savefig('rail_phase_velocity.png')
    plt.show()

##################################
# Mode shape visualization
ik, imode = 49, 9 #parameter index, mode index to visualize
print(f"f={wg.omega[ik]/(2*np.pi*T0):1.1f}Hz, l={2*np.pi*L0/wg.eigenvalues[ik][imode].real:1.2f}m")
vec = wg.eigenvectors[ik].getColumnVector(imode)
grid_interp = pyvista.UnstructuredGrid(*dolfinx.plot.create_vtk_mesh(Vmesh))
grid = pyvista.UnstructuredGrid(*dolfinx.plot.create_vtk_mesh(V))
grid["u"] = np.array(vec).real.reshape(int(np.array(vec).size/V.element.value_shape), int(V.element.value_shape)) #V.element.value_shape is equal to 3
grid_interp = grid_interp.interpolate(grid) #interpolation onto a finite element mesh of order 1 to plot both the FE mesh and the results with pyvista
plotter = pyvista.Plotter()
plotter.add_mesh(grid_interp.warp_by_vector("u", factor=0.1), show_scalar_bar=False, show_edges=True)
#plotter.show_axes()
plotter.view_xy()
plotter.screenshot('rail_mode_shape.png', transparent_background=True)
plotter.show()

