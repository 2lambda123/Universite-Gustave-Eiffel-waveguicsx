<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>waveguicsx &mdash; waveguicsx 1.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Modules" href="modules.html" />
    <link rel="prev" title="Waveguicsx - Version 1.0" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/logo_doc.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">waveguicsx</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">0. Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#prerequisites">1. Prerequisites</a></li>
<li class="toctree-l2"><a class="reference internal" href="#installation">2. Installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#documentation">3. Documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#tutorials">4. Tutorials</a></li>
<li class="toctree-l2"><a class="reference internal" href="#authors-and-contributors">5. Authors and contributors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-to-cite">6. How to cite</a></li>
<li class="toctree-l2"><a class="reference internal" href="#license">7. License</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="waveguicsx.html">waveguicsx.waveguide</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a><ul>
<li class="toctree-l2"><a class="reference internal" href="examples.html#d-elastic-bar-of-square-cross-section">3D elastic bar of square cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#d-elastic-bar-of-square-cross-section-with-parallelization">3D elastic bar of square cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#d-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium">3D elastic bar of square cross-section buried into a PML external medium</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#d-elastic-bar-of-square-cross-section-buried-into-a-pml-external-medium-using-gmsh">3D elastic bar of square cross-section buried into a PML external medium using gmsh</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#excitation-of-a-3d-elastic-bar-of-circular-cross-section">Excitation of a 3D elastic bar of circular cross-section</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#excitation-of-a-3d-elastic-bar-of-circular-cross-section-with-parallelization">Excitation of a 3D elastic bar of circular cross-section with parallelization</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#time-response-of-a-plate-excited-near-its-first-zgv-resonance">Time response of a plate excited near its first ZGV resonance</a></li>
<li class="toctree-l2"><a class="reference internal" href="examples.html#dispersion-curves-of-a-rail">Dispersion curves of a rail</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">waveguicsx</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">waveguicsx</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/readme_link.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="waveguicsx">
<h1>waveguicsx<a class="headerlink" href="#waveguicsx" title="Permalink to this heading"></a></h1>
<p>waveguicsx, a python library for solving complex waveguide problems<br />
Copyright (C) 2023  Fabien Treyssede</p>
<p>This file is part of waveguicsx.</p>
<p>waveguicsx is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>waveguicsx is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with waveguicsx. If not, see <a class="reference external" href="https://www.gnu.org/licenses/">https://www.gnu.org/licenses/</a>.</p>
<p>Contact: fabien.treyssede&#64;univ-eiffel.fr</p>
<section id="introduction">
<h2>0. Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading"></a></h2>
<p>Waveguicsx is a python library for solving complex waveguide problems based on SLEPc eigensolver.</p>
<p>The full documentation is entirely defined in the `waveguide.py’ module.</p>
<p>Waveguicsx can deal with complex waveguides, two-dimensional (e.g. plates) or three-dimensional (arbitrarily shaped cross-section), inhomogeneous in the transverse directions, anisotropic. Complex-valued problems can be handled including the effects of non-propagating modes (evanescent, inhomogeneous), viscoelastic loss (complex material properties) or perfectly matched layers (PML) to simulate buried waveguides.</p>
<p>More precisely, waveguicsx solves the following matrix problem: <span class="math notranslate nohighlight">\((\textbf{K}_0-\omega^2\textbf{M}+\text{i}k(\textbf{K}_1+\textbf{K}_1^\text{T})+k^2\textbf{K}_2)\textbf{U}=\textbf{F}\)</span>. This kind of problem typically stems from the so-called semi-analytical finite element (FE) method. See references below for theoretical details.</p>
<p>The inputs of waveguicsx are: the matrices <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> (PETSc matrix format) to compute the free response of waveguide (dispersion curves), as well as the excitation vector <span class="math notranslate nohighlight">\(\textbf{F}\)</span> if computing forced response is required. These matrices can be built from your own favorite code. In this case, you just need to import these matrices to Python and converted them to PETSc format (see basic examples below). In case you do not have any code to generate these matrices, you can use the open finite element software FEniCSX (installation required) as shown in the tutorials.</p>
<p>The free response (<span class="math notranslate nohighlight">\(\textbf{F}=\textbf{0}\)</span>) corresponds an eigenvalue problem, solved iteratively by varying the parameter which can be
the angular frequency <span class="math notranslate nohighlight">\(\omega\)</span> or the wavenumber <span class="math notranslate nohighlight">\(k\)</span>, leading to dispersion curve results. In the former case, the eigenvalue is <span class="math notranslate nohighlight">\(k\)</span>, while in the latter case, the eigenvalue is <span class="math notranslate nohighlight">\(\omega^2\)</span>. The loops over the parameter (angular frequency or wavenumber) can be parallelized, as shown in some tutorials (using mpi4py). Various modal properties (energy velocity, group velocity, excitability…) can be post-processed as a function of the frequency and plotted as dispersion curves.</p>
<p>The forced reponse (<span class="math notranslate nohighlight">\(\textbf{F}\neq\textbf{0}\)</span>) is solved in the frequency domain by expanding the solution as a sum of eigenmodes using biorthogonality relationship, leading to very fast computations of the excited wavefields. The transient response can finally be processed in the time domain by inverse FFT.</p>
<p>The library contains two classes. The main class, the class Waveguide, enables to solve the waveguide problem defined by the following inputs: <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> and <span class="math notranslate nohighlight">\(\textbf{F}\)</span>. The other class, the class Signal, is provided to easily handle the transforms of signals from frequency to time and inversely, as well as the generation of excitation pulses.</p>
<p><strong>Basic example 1: dispersion curves of a homogeneous plate</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">###########################################</span>
<span class="c1"># Basic example 1: dispersion curves of a homogeneous plate</span>
<span class="c1">#</span>
<span class="c1"># Important note:\</span>
<span class="c1"># This basic example uses previously built PETSc matrices stored into a binary file.\</span>
<span class="c1"># If you want to use your own matrices, you have to convert them to PETSc format. Examples of conversion are given below.\</span>
<span class="c1"># ** Conversion of a 2d numpy array M to PETSc (dense matrix): **\</span>
<span class="c1"># M = PETSc.Mat().createDense(M.shape, array=M)\</span>
<span class="c1"># ** Importing sparse matrix M from Matlab to scipy (sparse matrix): **\</span>
<span class="c1"># matrices = scipy.io.loadmat(&#39;matlab_file.mat&#39;) #here, the Matlab file &#39;matlab_file.mat&#39; is supposed to contain the variable M (Matlab sparse matrix)\</span>
<span class="c1"># M = matrices[&#39;M&#39;] #&#39;M&#39; is the name of the Matlab variable\</span>
<span class="c1"># ** Conversion of a scipy sparse matrix M to PETSc: **\</span>
<span class="c1"># M = M.tocsr() #convert to csr format first\</span>
<span class="c1"># M = PETSc.Mat().createAIJ(size=M.shape, csr=(M.indptr, M.indices, M.data))</span>

<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">petsc4py</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">waveguicsx.waveguide</span> <span class="kn">import</span> <span class="n">Waveguide</span>

<span class="c1">###########################################</span>
<span class="c1"># Load PETSc matrices, K0, K1, K2 and M saved into the binary file &#39;BasicExample_K0K1K2MF.dat&#39;.\</span>
<span class="c1"># This file contains matrices for a homogeneous plate of thickness 1 and Poisson ratio 0.3.\</span>
<span class="c1"># It can be found in the subfolder &#39;examples&#39;\</span>
<span class="c1"># (file generated from the tutorial &#39;Elastic_Waveguide_Plate2D_TransientResponse.py&#39;)</span>
<span class="n">viewer</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span><span class="o">.</span><span class="n">createBinary</span><span class="p">(</span><span class="s1">&#39;BasicExample_K0K1K2MF.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#note: calls below must be in order that objects have been stored</span>
<span class="n">K0</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K1</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>

<span class="c1">###########################################</span>
<span class="c1"># Initialization of waveguide</span>
<span class="n">wg</span> <span class="o">=</span> <span class="n">Waveguide</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span> <span class="c1">#set the parameter range (here, normalized angular frequency)</span>
<span class="c1">#wg.set_parameters(wavenumber=np.arange(0.1, 10.1, 0.1)) #uncomment this line if the parameter is the wavenumber instead of the angular frequency (reduce also nev)</span>

<span class="c1">###########################################</span>
<span class="c1"># Solution of eigenvalue problem (iteration over parameter)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#access to eigensolutions with: wg.eigenvalues[iomega][imode], wg.eigenvectors[iomega][idof,imode]</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_energy_velocity</span><span class="p">()</span> <span class="c1">#post-process energy velocity</span>

<span class="c1">###########################################</span>
<span class="c1"># Plot dispersion curves (by default, normalized)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1">#normalized angular frequency vs. normalized wavenumber</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_energy_velocity</span><span class="p">()</span> <span class="c1">#normalized energy velocity vs. normalized angular frequency</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">###########################################</span>
<span class="c1"># Example of dimensional plots</span>
<span class="n">h</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">rho</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">3260</span><span class="p">,</span> <span class="mi">7800</span> <span class="c1">#plate thickness (m), shear wave celerity (m/s), density (kg/m**3)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_plot_scaler</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">h</span><span class="o">/</span><span class="n">cs</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="n">rho</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#set characteristic length, time and mass</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span> <span class="c1">#frequency (Hz) vs. wavenumber (1/m)</span>
<span class="c1">#wg.plot_energy_velocity() #energy velocity (m/s) vs. frequency (Hz)</span>
<span class="c1"># Energy velocity plot with user-defined units (here, m/ms vs. MHz-mm)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s2">&quot;energy_velocity&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">/</span><span class="mi">1000</span> <span class="c1">#units in m/ms</span>
<span class="n">wg</span><span class="o">.</span><span class="n">plot_scaler</span><span class="p">[</span><span class="s2">&quot;frequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cs</span><span class="o">/</span><span class="mi">1000</span> <span class="c1">#frequency units in MHz-mm</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">plot_energy_velocity</span><span class="p">(</span><span class="n">direction</span><span class="o">=+</span><span class="mi">1</span><span class="p">)</span> <span class="c1">#plot positive-going modes</span>
<span class="n">sc</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency-thickness (MHz-mm)&#39;</span><span class="p">)</span>
<span class="n">sc</span><span class="o">.</span><span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Energy velocity (m/ms)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>Basic example 2: forced response of a homogeneous plate</strong></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1">###########################################</span>
<span class="c1"># Basic example 2: forced response of a homogeneous plate</span>
<span class="c1">#</span>
<span class="c1"># Important note:\</span>
<span class="c1"># This basic example uses previously built PETSc matrices stored into a binary file.\</span>
<span class="c1"># If you want to use your own matrices, you have to convert them to PETSc format. Examples of conversion are given below.\</span>
<span class="c1"># ** Conversion of a 2d numpy array M to PETSc (dense matrix): **\</span>
<span class="c1"># M = PETSc.Mat().createDense(M.shape, array=M)\</span>
<span class="c1"># ** Importing sparse matrix M from Matlab to scipy (sparse matrix): **\</span>
<span class="c1"># matrices = scipy.io.loadmat(&#39;matlab_file.mat&#39;) #here, the Matlab file &#39;matlab_file.mat&#39; is supposed to contain the variable M (Matlab sparse matrix)\</span>
<span class="c1"># M = matrices[&#39;M&#39;] #&#39;M&#39; is the name of the Matlab variable\</span>
<span class="c1"># ** Conversion of a scipy sparse matrix M to PETSc: **\</span>
<span class="c1"># M = M.tocsr() #convert to csr format first\</span>
<span class="c1"># M = PETSc.Mat().createAIJ(size=M.shape, csr=(M.indptr, M.indices, M.data))</span>

<span class="kn">from</span> <span class="nn">mpi4py</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="kn">from</span> <span class="nn">petsc4py</span> <span class="kn">import</span> <span class="n">PETSc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">waveguicsx.waveguide</span> <span class="kn">import</span> <span class="n">Waveguide</span><span class="p">,</span> <span class="n">Signal</span>

<span class="c1">###########################################</span>
<span class="c1"># Load PETSc matrices, K0, K1, K2 and M, as well as PETSc vector F, saved into the binary file &#39;BasicExample_K0K1K2MF.dat&#39;.\</span>
<span class="c1"># This file contains matrices for a homogeneous plate of thickness 1 and Poisson ratio 0.3.\</span>
<span class="c1"># It can be found in the subfolder &#39;examples&#39;\</span>
<span class="c1"># (file generated from the tutorial &#39;Elastic_Waveguide_Plate2D_TransientResponse.py&#39;)</span>
<span class="n">viewer</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Viewer</span><span class="p">()</span><span class="o">.</span><span class="n">createBinary</span><span class="p">(</span><span class="s1">&#39;BasicExample_K0K1K2MF.dat&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#note: calls below must be in order that objects have been stored</span>
<span class="n">K0</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K1</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">K2</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Mat</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">PETSc</span><span class="o">.</span><span class="n">Vec</span><span class="p">()</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">viewer</span><span class="p">)</span>

<span class="c1">###########################################</span>
<span class="c1"># Input parameters</span>
<span class="n">h</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">cs</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mi">7800</span><span class="p">,</span> <span class="mi">3218</span> <span class="c1">#plate thickness (m), density (kg/m3), shear wave celerity (m/s)</span>
<span class="n">nev</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1">#number of eigenvalues requested at each frequency</span>

<span class="c1">###########################################</span>
<span class="c1"># Excitation spectrum (toneburst)</span>
<span class="n">excitation</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">()</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">toneburst</span><span class="p">(</span><span class="n">fs</span><span class="o">=</span><span class="mf">400e3</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mf">2e-3</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="mf">100e3</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="c1">#central frequency 100 kHz, 8 cycles, duration 2 ms</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">excitation</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">excitation</span><span class="o">.</span><span class="n">frequency</span> <span class="c1">#angular frequency range (rad/s)</span>
<span class="n">omega</span> <span class="o">=</span> <span class="n">omega</span><span class="o">*</span><span class="n">h</span><span class="o">/</span><span class="n">cs</span> <span class="c1">#normalize angular frequency, because PETSC matrices have been generated for a plate of thickness 1</span>

<span class="c1">###########################################</span>
<span class="c1"># Initialization of waveguide</span>
<span class="n">wg</span> <span class="o">=</span> <span class="n">Waveguide</span><span class="p">(</span><span class="n">MPI</span><span class="o">.</span><span class="n">COMM_WORLD</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K0</span><span class="p">,</span> <span class="n">K1</span><span class="p">,</span> <span class="n">K2</span><span class="p">)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="n">omega</span><span class="p">)</span> <span class="c1">#set the parameter range (here, normalized angular frequency)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">set_plot_scaler</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">h</span><span class="o">/</span><span class="n">cs</span><span class="p">,</span> <span class="n">mass</span><span class="o">=</span><span class="n">rho</span><span class="o">*</span><span class="n">h</span><span class="o">**</span><span class="mi">3</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1">#uncomment this line if you want to plot dimensional results, otherwise comment for normalized results</span>

<span class="c1">###########################################</span>
<span class="c1"># Free response (dispersion curves)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">nev</span><span class="o">=</span><span class="n">nev</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1">#solution of eigenvalue problem (iteration over parameter)</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_group_velocity</span><span class="p">()</span> <span class="c1">#post-process group velocity</span>

<span class="c1">###########################################</span>
<span class="c1"># Computation of modal coefficients due to excitation vector F</span>
<span class="c1"># and modal excitabilities at degree of freedom dof</span>
<span class="c1"># F is a unit point force applied normally to the bottom surface of the plate</span>
<span class="n">wg</span><span class="o">.</span><span class="n">compute_response_coefficient</span><span class="p">(</span><span class="n">F</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">dof</span><span class="o">=</span><span class="mi">38</span><span class="p">)</span> <span class="c1">#here, dof index 38 is x-component (i.e. normal to the plate) at x=1 (i.e. top of the plate)</span>
<span class="n">sc</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">plot_energy_velocity</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;excitability&#39;</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">],</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;log&#39;</span><span class="p">)</span> <span class="c1">#plot the energy velocity colored by the excitability modulus</span>
<span class="n">sc</span><span class="o">.</span><span class="n">colorbar</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;excitability&#39;</span><span class="p">)</span>
<span class="c1">#sc.axes.set_ylim([0, 2*cs]) #set y limits if necessary</span>
<span class="c1">#sc.set_clim([1e-14,1e-11]) #set colorbar limits if necessary</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1">###########################################</span>
<span class="c1"># Forced response at degree of freedom dof and axial coordinates z (z is normalized by h)</span>
<span class="n">frequency</span><span class="p">,</span> <span class="n">response</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">compute_response</span><span class="p">(</span><span class="n">dof</span><span class="o">=</span><span class="mi">38</span><span class="p">,</span> <span class="n">z</span><span class="o">=</span><span class="p">[</span><span class="mi">50</span><span class="p">],</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">excitation</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="c1">#response in the frequency domain at z/h=50</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="n">response</span><span class="p">)</span>
<span class="n">response</span><span class="o">.</span><span class="n">plot_spectrum</span><span class="p">()</span>
<span class="n">response</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>
<span class="n">response</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="prerequisites">
<h2>1. Prerequisites<a class="headerlink" href="#prerequisites" title="Permalink to this heading"></a></h2>
<p>Waveguicsx requires SLEPc and PETSc (slepc4py, petsc4py).</p>
<p>The necessary inputs to waveguicsx are the matrices <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> (PETSc matrix format) to compute the free response of waveguide (dispersion curves), as well as the vector <span class="math notranslate nohighlight">\(\textbf{F}\)</span> to compute the forced response. These matrices can be built from any code, then imported to Python and converted to PETSc format.</p>
<p><strong>Tutorials:</strong></p>
<p>In the tutorials (see subfolder ‘examples’), these matrices are built from the open finite element (FE) platform FEniCSX. To run these tutorials, you will therefore need to install FEniCSX first. Note that tutorials are py files formatted such that they can be conveniently opened in a text editor or in a jupyter notebook.</p>
<p><em>Tutorial files are currently written for FEniCSX v0.6.0, minor modifications may be required for use with latest versions (work under progress).</em></p>
</section>
<section id="installation">
<h2>2. Installation<a class="headerlink" href="#installation" title="Permalink to this heading"></a></h2>
<section id="clone-the-waveguicsx-public-repository">
<h3>2.1 Clone the Waveguicsx public repository<a class="headerlink" href="#clone-the-waveguicsx-public-repository" title="Permalink to this heading"></a></h3>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>git<span class="w"> </span>clone<span class="w"> </span>https://github.com/Universite-Gustave-Eiffel/waveguicsx.git
<span class="nb">cd</span><span class="w"> </span>./waveguicsx
</pre></div>
</div>
</section>
<section id="generate-the-docker-image-and-run-the-container-using">
<h3>2.2 Generate the docker image and run the container using :<a class="headerlink" href="#generate-the-docker-image-and-run-the-container-using" title="Permalink to this heading"></a></h3>
<p>FEniCSX is not a dependency of Waveguicsx. Nevertheless, it is required to run the tutorials.
We recommend using the docker image of DOLFINX/v0.6.0 sourced in complex mode before running the tutorials :</p>
<p>Install <a class="reference external" href="https://docs.docker.com/engine/install">Docker</a> and authorize <a class="reference external" href="https://docs.docker.com/engine/install/linux-postinstall/">non-root users</a></p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>./launch_fenicsx.sh
</pre></div>
</div>
<p>Once the container is launched, install the package using (only the first time)</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>python3<span class="w"> </span>-m<span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>-e<span class="w"> </span>.
</pre></div>
</div>
<p><em>WARNING</em> : the waveguicsx folder (i.e. <code class="docutils literal notranslate"><span class="pre">.</span></code>) is mounted inside the container in <code class="docutils literal notranslate"><span class="pre">/home/waveguicsxuser</span></code> :
so that all changes are persistent and modify the repository of the host system as well.<br />
The python package files will be installed in the <code class="docutils literal notranslate"><span class="pre">.local</span></code> folder (ignored by <code class="docutils literal notranslate"><span class="pre">git</span></code>),
so that it is not necessary to reinstall the package with pip each time the container is launched.</p>
<p>Usage inside the container :</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>real<span class="w">  </span><span class="c1"># =&gt; use the real libraries of dolfinx</span>
<span class="o">[</span>real<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>complex<span class="w">  </span><span class="c1"># back to complexe mode</span>
<span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>python3<span class="w"> </span>./examples/Elastic_Waveguide_SquareBar3D.py<span class="w">  </span><span class="c1"># run the examples in cli</span>
<span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span>jupyter<span class="w"> </span>notebook<span class="w">  </span><span class="c1"># to launch the jupyter notebook from inside the container</span>
<span class="o">[</span>complex<span class="o">]</span>waveguicsxuser@hostname:~$<span class="w"> </span><span class="nb">exit</span><span class="w">  </span><span class="c1"># to leave the container</span>
</pre></div>
</div>
</section>
</section>
<section id="documentation">
<h2>3. Documentation<a class="headerlink" href="#documentation" title="Permalink to this heading"></a></h2>
<p>The full documentation is entirely defined in the `waveguide.py’ module.</p>
<p>You can also build the documentation, using <code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">setup.py</span> <span class="pre">doc</span></code> and opening the front page in <code class="docutils literal notranslate"><span class="pre">./doc/Waveguicsx_documentation.html</span></code>.</p>
</section>
<section id="tutorials">
<h2>4. Tutorials<a class="headerlink" href="#tutorials" title="Permalink to this heading"></a></h2>
<p>Various tutorials are provided in the subfolder ‘examples’. These tutorials fully depict simple as well as more complex problems, two-dimensional (plates) or three-dimensional (bars, rail…), including viscoelastic loss or perfectly matched layers (used for buried waveguides). In particular, these tutorials show how to build the finite element matrices <span class="math notranslate nohighlight">\(\textbf{K}_0\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_1\)</span>, <span class="math notranslate nohighlight">\(\textbf{K}_2\)</span>, <span class="math notranslate nohighlight">\(\textbf{M}\)</span> with FEniCSX. Installing FEniCSX is therefore required to run the tutorials.</p>
<p>In case you have your own code to generate these matrices, you can readily forget FEniCSX parts in each tutorial, and only consider the part dedicated to waveguicsx.</p>
</section>
<section id="authors-and-contributors">
<h2>5. Authors and contributors<a class="headerlink" href="#authors-and-contributors" title="Permalink to this heading"></a></h2>
<p>Waveguicsx is currently developed and maintained at Université Gustave Eiffel by Dr. Fabien Treyssède, with some contributions from Dr. Maximilien Lehujeur (github software management, python formatting, beta testing) and Dr. Pierric Mora (parallelization of loops in tutorials, beta testing). Please see the AUTHORS file for a list of contributors.</p>
<p>Feel free to contact me by email for further information or questions about waveguicsx.</p>
<p>contact: fabien.treyssede&#64;univ-eiffel.fr</p>
</section>
<section id="how-to-cite">
<h2>6. How to cite<a class="headerlink" href="#how-to-cite" title="Permalink to this heading"></a></h2>
<p>Please cite the software project as follows if used for your own projects or academic publications:</p>
<p>F. Treyssède, waveguicsx (a python library for solving complex waveguides problems), 2023; software available at https://github.com/treyssede/waveguicsx.</p>
<p>For theoretical details about finite element modeling of waveguide problems, here are also a few references by the author about the SAFE modeling of waveguides:</p>
<p>F. Treyssède, L. Laguerre, Numerical and analytical calculation of modal excitability for elastic wave generation in lossy waveguides, Journal of the Acoustical Society of America 133 (2013), 3827–3837</p>
<p>K. L. Nguyen, F. Treyssède, C. Hazard, Numerical modeling of three-dimensional open elastic waveguides combining semi-analytical finite element and perfectly matched layer methods, Journal of Sound and Vibration 344 (2015), 158-178</p>
<p>F. Treyssède, Spectral element computation of high-frequency leaky modes in three-dimensional solid waveguides, Journal of Computational Physics 314 (2016), 341-354</p>
<p>M. Gallezot, F. Treyssède, L. Laguerre, A modal approach based on perfectly matched layers for the forced response of elastic open waveguides, Journal of Computational Physics 356 (2018), 391-409</p>
</section>
<section id="license">
<h2>7. License<a class="headerlink" href="#license" title="Permalink to this heading"></a></h2>
<p>Waveguicsx is freely available under the GNU GPL, version 3.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Waveguicsx - Version 1.0" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="modules.html" class="btn btn-neutral float-right" title="Modules" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Fabien Treyssede.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>